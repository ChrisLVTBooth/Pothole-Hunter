# Pothole-Hunter
First steps towards a 'pothole hunter' as practice in designing, building and programming with sensor feedback

Pothole Hunter was developed for practice in designing, building and programming with sensor feedback. Developed in a 'Hardware' module of the MRAC course, the bot requires also python and other software programming to get the hardware to work as a roving bot capable of responding to specific objects detected by its sensors.
The initial concept was to build a small mobile robot to simulate detecting and filling potholes, which would require the ability to:
● recognize and detect potholes
● navigate to the closest pothole
● manoeuvre correctly to position an end effector directly over the pothole (done outside the system's field of vision)
● fill the pothole
● continue to the next pothole
In practice, the goals were scaled back while maintaining the core goal of learning to build and program a complete bot with sensor feedback. In practice the desired ability of recognizing and detecting potholes was simplified to recognizing and detecting 'blobs' within a colour range - in fact oranges as can be seen in the videos below! This simplification was mainly due to time constraints, brought about mainly by an unfortunate situation in which the timing of the development of the project came immediately after the release of the updated Raspberry Pi IV microcomputers but before any new software for the new 'camera stack' was generally available. This resulted in quite a lot of time being spent unsuccessfully trying to use the Raspberry Pi IV and the new official Raspberry Pi camera module together, which had to be abandoned due to the lack of software available at the time, and having to opt for an alternative object-recognition hardware/software solution, in a reduced timeframe. This is why the blog post contains some images with the Raspberry Pi camera module mounted in the bot, but the videos in fact use a mobile phone attached to the bot in order to use its camera instead.
Hardware Overview
The bot uses a simple rectangular aluminium frame (universally available 20mm x 20mm extrusion) below which are mounted two motorized wheels (DC motors with encoders, and motor drivers) and a castor wheel and above which is mounted the remaining hardware: an Arduino Uno R3 microprocessor (blue in image below) controls the motion system, a Raspberry Pi 4 microprocessor was intended to control the vision system, a Raspberry Pi V2 camera (both green in image below) but in the end a mobile phone was used as a camera (and off-board image processing was used instead of the Raspberry Pi 4). A 12V solenoid controlled the release of a liquid from a recipient to a tube which deposited it where the 'pothole' was. A distance sensor was positioned to detect when the liquid filled the 'pothole' to the required level. Screw couplings, 5V regulators, 3S Lipo batteries and some 3D printed parts completed the set up.
Hardware Bill Of Materials
If anyone wants to reproduce this bot completely or partially, the BOM lists the hardware elements, basic notes and a link to manufacturers information or suppliers.
Core Electronic Component Connections
The diagram fritzing.png, in the Misc images folder, shows the core electronic connections (it is high enough resolution to zoom in and identify all connections in detail), but the Raspberry Pi and its camera are not included because finally we did not use them.
However, if we had managed to use the Raspberry Pi 4 with the Camera Module 2, the Raspberry Pi would have received power from the H-Bridge 5V outputs (bottom right hand in image - the same as those from the H-Bridge to the Arduino Uno), the camera is always connected directly to the Raspberry Pi 4 with a cable attached to the camera at purchase (connection details here: https://projects.raspberrypi.org/en/projects/getting-started-with-picamera) and the connection between the Raspberry Pi and the Arduino Uno would have been by USB.
Steering
A key design element of the bot is the simplicity of the hardware layout for steering which allows relative simplicity in programming the bot's motion.
The bot has three wheels. One, the rear wheel, is a non-motorized castor wheel - it can rotate about a vertical axis to be able to point and move in any direction, but simply following the lead set by the other two wheels, which are identical and motorized. In this arrangement, if the left hand wheel is driven forward while the right hand wheel remains stationary, the bot rotates to the right. And conversely, if the right hand wheel is driven forward while the left hand wheel remains stationary, the bot rotates to the left. Of course if both powered wheels are driven together at the same speed, the bot moves straight forward. These three options are shown in the image Pothole hunter - Steering I.png.
Simultaneously, our requirements in terms of navigating directly towards a detected object in the field of vision are very similar: assuming the vision system is looking straight forward in front of the bot, if an object is detected in the right hand part of the image, then the bot needs to be rotated to the right to be pointing straight at it. Conversely, if an object is detected in the left hand part of the image, then the bot needs to be rotated to the left to be pointing straight at it. Of course when an object is detected at the centre of the image the bot is already pointing straight at it and so needs to be driven stright forward to reach it. These three options are shown in Pothole Hunter - Steering II.png. 
Pseudocode
The logic of these simple movements is at the core of the 'pseudocode' which lets us move from what the vision system detects (an object in the left, centre, or right of a series of frames) to giving appropriate instructions to the wheels to achieve the desired goal - steering the bot until the detected object is at the bottom of the centre of the field of vision. When this is achieved, which is called 'Oriented' in the pseudocode image below, a fourth movement option (additional to Turn left, Go straight and Turn right) is programmed which is called 'Move to hole'.

'Move to hole' is a movement straight forward the required distance to position the liquid-dispensing hardware of the bot, consisting of a small recipient a solenoid and a tube, directly over the point where the detected object left the field of vision.
The image 'Pothole Hunter Pseudocode 02.png' shows this pseudocode graphically.

In the pseudocode shown graphically in 'Pothole Hunter Pseudocode 02.png' shows the entire process. Unlike previous pseudocode described, which focuses on linking the vision system to the steering, this pseudocode includes the process of filling the pothole. Our bot did have a functioning 'pothole filling system' - the solenoid was functional and the python coding included to begin to release liquid after the bot was positioned over the 'pothole' and to stop releasing liquid when a sensor detected a fill-level had been reached - but its use does not appear in any videos since our detection was restricted to orange blobs and not potholes. 

Actual Code

There is python code - pothole hunter.py - written to be run on the Raspberry Pi but finally run on a laptop because of the camera stack problems with the new Raspberry Pi 4. It is in the Code folder.
The code for the Arduino Uno is also there - Arduino.ino

There are several videos of the 'Pothole Hunter' in action in the Videos folder.

Pothole Hunter is a project of IAAC, Institute for Advanced Architecture of Catalonia, developed at the Master of Robotics and Advanced Construction in 2021-2022 by:
Students: Huanyu Li, Libish Murugesan, Christopher Booth and Tomás Quijano
Faculty: Oscar Gonzalez, and Assistant Faculty: Daniil Koshelyuk